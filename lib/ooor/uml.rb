#    OOOR: OpenObject On Ruby
#    Copyright (C) 2009-2012 Akretion LTDA (<http://www.akretion.com>).
#    Author: RaphaÃ«l Valyi
#    Licensed under the MIT license, see MIT-LICENSE file

module Ooor
  module UML
    #usage: UML.print_uml or with options: UML.print_uml(:all, :detailed) or MyOpenObjectResource.print_uml or UML.print_uml([list_of_classes], :all, :detailed)

    def print_uml(options={})
      ooor = self.class.ooor
      UML.print_uml(ooor.config[:models] && ooor.loaded_models.select {|model| ooor.config[:models].index(model.openerp_model)} || ooor.loaded_models, options)
    end

    def serve_uml(options={})#TODO port
      ooor = self
      require 'sinatra'
      set :public, File.dirname(__FILE__) + '/../../'

      get '/model/:model_name' do
        model_name = params[:model_name]
        model = ooor.const_get(model_name)
        model.print_uml
        s = ""#"Hello world! #{model_name}"
        s << "<IMG SRC='/x.png' USEMAP='#UMLbyOOOR' />"
        f=File.open('x.map')
        f.each_line {|l| s << l}
        s
      end

      Sinatra::Application.run!
    end

    def self.display_fields(clazz)
      s = ""
      clazz.reload_fields_definition if clazz.fields.empty?
      #clazz.fields.sort {|a,b| a[1]['type'] <=> b[1]['type']}.each {|i| s << "+ #{i[1]['type']} : #{i[0]}\\l\\n"}
    clazz.fields.sort {|a,b| a[1]['type'] <=> b[1]['type']}.each {|i| s << "<TR><TD COLSPAN=\"2\" BGCOLOR=\"#bed1b8\" ALIGN=\"LEFT\">#{i[0]}</TD><TD ALIGN=\"LEFT\">#{i[1]['type']}</TD></TR>\\l\\n"}
      s
    end

    def self.print_uml(classes, options={})
#      options = options[0] if options[0].is_a?(Array)
#      local = (options.index(:all) == nil)
#      detailed = (options.index(:detailed) != nil) || local && (options.index(:nodetail) == nil)
      return if classes.empty?
      local = true
      detailed = true
      file_name = options[:file_name] || classes[0].name
      if classes.size > 8
        enabled_targets = classes.map {|i| i.openerp_model} #classes[0].ooor.config[:models] #defines the scope of the UML for option local
      else
        enabled_targets = classes[0].ooor.config[:models] #defines the scope of the UML for option local
      end

      m2o_edges = {}
      o2m_edges = {}
      m2m_edges = {}
      #instead of diplaying several relations of the same kind between two nodes which would bloat the graph,
      #we track them all and factor them on a common multiline edge label:
      connex_classes = UML.collect_edges(false, local, classes, enabled_targets, m2o_edges, o2m_edges, m2m_edges)
      #back links from connex classes:
      connex_classes += UML.collect_edges(true, local, connex_classes - classes, classes, m2o_edges, o2m_edges, m2m_edges)

      File.open("#{file_name}.dot", 'w') do |f|
        f << <<-eos
        digraph UMLbyOOOR {
            fontname = "Helvetica"
            #{classes.size < 5 && "layout = fdp" || ""}
            fontsize = 11
            splines = polyline
            label = "*** generated by OOOR by www.akretion.com ***"
            node [
                    fontname = "Helvetica"
                    fontsize = 11
                    shape = "record"
                    fillcolor=orange
                    style="rounded,filled"
            ]
            edge [
                    arrowhead = "none"
                    fontname = "Helvetica"
                    fontsize = 9
            ]
        eos

        #UML nodes definitions
        ((connex_classes - classes) + classes - [IrModel, IrModel.const_get('ir.model.fields')]).each do |model|
          #f << " #{model} [ label = \"{#{model.name}#{detailed ? '|' + display_fields(model) : ''}}\" URL=\"/model/#{model.openerp_model}\"];\n"
      f << "#{model}[label=<<TABLE BORDER=\"0\" CELLBORDER=\"1\" CELLSPACING=\"0\" BGCOLOR=\"#ffffff\"><TR><TD COLSPAN=\"3\" BGCOLOR=\"#9bab96\" ALIGN=\"CENTER\">#{model.name}</TD></TR>#{(classes.index(model) || classes.size == 1) && display_fields(model) || ''}</TABLE>> URL=\"/model/#{model.openerp_model}\"];\n"
        end

        #many2one:
        f << <<-eos
            edge [
                  headlabel = "1"
                  taillabel = "n"
            ]
            eos
        m2o_edges.each do |k, v|
          reverse_part = v[3].size > 0 ? "\\n/#{v[3].join("\\n")}\"]\n" : "\"]\n"
          f << "edge [label = \"#{v[2].join("\\n")}#{reverse_part}"
          f << "#{v[0]} -> #{v[1]}\n"
        end

        #one2many:
        f << <<-eos
            edge [
                  headlabel = "n"
                  taillabel = "1"
            ]
            eos
        o2m_edges.each do |k, v|
          f << "edge [label = \"#{v[3].join("\\n")}\"]\n"
          f << "#{v[0]} -> #{v[1]}\n"
        end

        #many2many:
        f << <<-eos
            edge [
                  headlabel = "n"
                  taillabel = "n"
            ]
            eos
        m2m_edges.each do |k, v|
          reverse_part = v[3].size > 0 ? "\\n/#{v[3].join("\\n")}\"]\n" : "\"]\n"
          f << "edge [label = \"#{v[2].join("\\n")}}#{reverse_part}"
          f << "#{v[0]} -> #{v[1]}\n"
        end

        f << "}"
      end

      begin
        cmd_line1 = "rm  #{file_name}.png"
        #system(cmd_line1)
      rescue
      end
      #cmd_line2 = "dot -Tpng uml.dot -o uml.png"
      cmd_line2 = "dot -Tcmapx -o#{file_name}.map -Tpng -o#{file_name}.png #{file_name}.dot"
      system(cmd_line2)
    end

    def self.collect_edges(is_reverse, local, classes, enabled_targets, m2o_edges, o2m_edges, m2m_edges)
      connex_classes = Set.new

      classes.each do |model|
        model.reload_fields_definition if model.fields.empty?

        #many2one:
        model.many2one_associations.each do |k, field|
          target = UML.get_target(is_reverse, local, enabled_targets, field, model)
          if target
            connex_classes.add(target)
            if m2o_edges["#{model}-#{target}"]
              m2o_edges["#{model}-#{target}"][2] += [k]
            else
              m2o_edges["#{model}-#{target}"] = [model, target, [k], []]
            end
          end

        end
      end

     classes.each do |model|
        #one2many:
        model.one2many_associations.each do |k, field|
          target = UML.get_target(is_reverse, local, enabled_targets, field, model)
          if target
            connex_classes.add(target)
            if m2o_edges["#{target}-#{model}"]
              m2o_edges["#{target}-#{model}"][3] += [k]
            elsif o2m_edges["#{model}-#{target}"]
              o2m_edges["#{model}-#{target}"][3] += [k]
            else
              o2m_edges["#{model}-#{target}"] = [model, target, [], [k]]
            end
          end
        end

        #many2many:
        model.many2many_associations.each do |k, field|
          target = UML.get_target(is_reverse, local, enabled_targets, field, model)
          if target
            connex_classes.add(target)
            if m2m_edges["#{model}-#{target}"]
              m2m_edges["#{model}-#{target}"][2] += [k]
            elsif m2m_edges["#{target}-#{model}"]
              m2m_edges["#{target}-#{model}"][3] += [k]
            else
              m2m_edges["#{model}-#{target}"] = [model, target, [k], []]
            end
          end
        end

      end
      connex_classes
    end

    private

    def self.get_target(is_reverse, local, enabled_targets, field, model)
      if (is_reverse && !local) || (!enabled_targets) || enabled_targets.index(field['relation'])
        model.const_get(field['relation'])
      else
        false
      end
    end
  end
end
